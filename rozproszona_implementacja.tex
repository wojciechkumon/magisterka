\chapter{Rozproszona implementacja}

Opisany algorytm dostosowany został do środowiska rozproszonego.
Taka implementacja pozwala uzyskać wysoką wydajność całego systemu, który staje się skalowany.
Osiąga się to poprzez horyzontalne replikowanie aplikacji, która obsługuje weryfikację modelową.
Uruchomione zostaje wiele instancji tego samego serwisu.

Dzięki jego bezstanowości (żadnych danych sesyjnych, które przechowywane są w pamięci pomiędzy zapytaniami do serwera) nie ma znaczenia, która replika obsłuży żądanie.
Każda wykona je identycznie, a cały stan odczytywany i umieszczany jest z wykorzystaniem bazy danych.
W środowisku chmurowym cały system może być dynamicznie dostosowywane do aktualnych potrzeb, aby zapewnić szybkość, ale także nie marnować zasobów.

Poniżej przedstawiony zostanie opis zrealizowanego systemu.


\section{Graph Builder}

GB inicjuje cały algorytm oraz działa jako dostawca stanów dla weryfikatora (uzyskuje je od GP).
Najpierw wybierana jest formuła LTL, która zostanie sprawdzona (szczegóły jej specyfikacji w sekcji \ref{sec:LTL_formula_spec}).
Następnie zaczyna się już główna część algorytmu.
Pobierane są stany początkowe, po czym przekazywane są LV oraz heurystyce przeszukującej graf.

Każda weryfikacja posiada swój unikalny identyfikator, aby móc prowadzić wiele z nich równolegle na tym samym grafie stanów.
Nadawanie go następuje podczas wysyłania pierwszych stanów do LV.
Używa się go później w każdej komunikacji z weryfikatorem.

Wykorzystywane jest przeszukiwanie wszerz (BFS) zgodnie z fazą \textit{initialise} (algorytm \ref{alg:initialise}).
Kolejne stany uzyskiwane od GP zostają zapisywane w bazie danych, a także sprawdzane przez LV, który zwraca informacje o statusie weryfikacji.
Może ona zakończyć się szybciej (działanie w locie) w przypadku formuły, która nie jest spełniana przez graf.
W przeciwnym wypadku pobierane są kolejne stany aż do pełnej eksploracji.

Po odwiedzeniu wszystkich węzłów w grafie następuje wykonanie weryfikacji odpowiadającej liniom 4-8 w algorytmie \ref{alg:detectAcceptingCycle} przez LV.
Po tym etapie jednoznacznie wiadomo, czy formuła została spełniona.

Kod prezentujący funkcjonalność realizowaną przez GB znajduje się w listingu \ref{lst:GB_pseudocode}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Kod algorytmu realizowanego przez GB w języku Java.},captionpos=b,label={lst:GB_pseudocode}]
public VerificationState checkModel() {
  Collection<SystemState> states = initialStates.initialStates();
  List<StoredSystemState> saved = store.save(states).getNewlyStoredStates();
  heuristic.newStates(saved);
  VerificationId verificationId = verificationService.init(saved);
  while (heuristic.hasMoreToExplore()) {
    if (heuristic.shouldVisitState()) {
      StoredSystemState toVisit = heuristic.nextStateToVisit();
      Collection<Transition> transitions = description.allTransitionFromState(
          toVisit.getSystemState());
      heuristic.newTransitions(toVisit, transitions);
    }
    if (heuristic.shouldExploreTransition()) {
      Pair<StoredSystemState, Transition> toExplore = 
          heuristic.nextTransitionToExplore();
      Collection<SystemState> reachableStates = description.allReachableStates(
          toExplore.getFirst().getSystemState(), toExplore.getSecond());
      StoredStatesResult result = store.save(reachableStates);
      List<StoredSystemState> storedOnlyNewStates = result.getNewlyStoredStates();
      if (!storedOnlyNewStates.isEmpty()) {
        store.save(toExplore.getFirst(),
            storedOnlyNewStates, toExplore.getSecond());
        heuristic.newStates(storedOnlyNewStates);
      }
      List<StoredSystemState> storedOnlyOldStates = result.getAlreadyStoredStates();
      if (!storedOnlyOldStates.isEmpty()) {
        store.save(toExplore.getFirst(), storedOnlyOldStates,
            toExplore.getSecond());
      }
      List<StoredSystemState> allReachableStates =
          new ArrayList<>(storedOnlyNewStates);
      allReachableStates.addAll(storedOnlyOldStates);
      if (!allReachableStates.isEmpty()) {
        VerificationResult verificationResult = verifyNewStates(
            verificationId, toExplore, allReachableStates);
        if (verificationResult.getVerificationState() == FORMULA_UNSATISFIED) {
          return FORMULA_UNSATISFIED;
        }
      }
    }
  }
  VerificationResult finishResult = verificationService.finish(verificationId);
  return finishResult.getVerificationState();
}
\end{lstlisting}
\end{minipage}


\section{Specyfikacja formuły LTL} \label{sec:LTL_formula_spec}

Obiektowa reprezentacja formuły LTL nie wystarcza, aby móc je tworzyć.
Potrzebny jest sposób umożliwiający zapis tekstem.
Dzięki temu można przygotowywać zestawy formuł, jakie powinien spełniać system, po czym wykorzystać je jako parametr dla weryfikatora.
Koniecznością więc było ich parsowanie.

Spełnić należało dwa wymagania.
Po pierwsze obsługiwać spójniki zdaniowe i operatory temporalne, jakie oferuje LTL.
Po drugie pozwolić elastyczność, co do samych warunków, tak aby móc je dowolnie komponować i łączyć.
Wspierać należało porównywanie dowolnych wartości modelu na różne sposoby, np. przez tę samą wartość, wyrażenia regularne, czy relację porządku.

Zamiast tworzenia własnego języka, wykorzystany został Kotlin poprzez jego silnik skryptowy.
Pozwala na nieograniczoną elastyczność w tworzeniu formuł.
Kod wykonywany jest locie i zamieniany na reprezentację obiektową.
Jego składnia pozwala na elegancką notację z wykorzystaniem operatorów infiksowych.

Obiekt formuły opisany został w sekcji \ref{sec:ltl2buchi}.
Do porównywania wartości wykorzystana została biblioteka \textit{Hamcrest} (\url{http://hamcrest.org}).
Oferuje ona bogaty zestaw komparatorów, możliwość ich łączenia i testowania na dowolnym obiekcie systemu.

Przykładowe formuły prezentuje listing \ref{lst:kotlin_formulas}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Przykładowe formuły LTL w języku Kotlin.},captionpos=b,label={lst:kotlin_formulas}]

val bfsPcEq1 = proposition(hasProperty<SystemState>("bfsHeuristicState", 
        hasProperty<Int>("pc", equalTo(1))))
val bfsPcGt1 = proposition(hasProperty<SystemState>("bfsHeuristicState",
        hasProperty<Int>("pc", greaterThan(1))))
val formula = globally(bfsPcEq1 implies finally(bfsPcGt1))


\end{lstlisting}
\end{minipage}

% TODO zapytać o sensowne formuły


\section{LTL to Büchi} \label{sec:ltl2buchi}

Do obiektowej reprezentacji formuły wykorzystana została biblioteka \textit{ltl2buchi} \\(\url{https://github.com/fraimondi/ltl2buchi}).
Pozwala ona na tworzenie formuł z dowolnymi twierdzeniami (wykorzystuje klasy generyczne).

Jej główną funkcjonalnością jest ich konwersja do grafów reprezentujących uogólnione automaty Büchiego.
Te są redukowane, degeneralizowane i znów redukowane.
Brakuje jednak zautomatyzowanej możliwości poruszania się po tym automacie.

Biblioteka wymagała zaadaptowania do potrzeb projektu.
Wyodrębniona została funkcja konwertująca formułę do grafu (listing \ref{lst:formula_to_graph}).

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Funkcja konwertująca formułę LTL do grafu.},captionpos=b,label={lst:formula_to_graph}]

    <T> Graph<T> ltlToBuchiAutomaton(Formula<T> formula) {
        val optimizedFormula = new Rewriter<>(formula).rewrite();
        Graph<T> gba = Translator.translate(optimizedFormula);
        Graph<T> reducedGba = SuperSetReduction.reduce(gba);
        Graph<T> ba = Degeneralize.degeneralize(reducedGba);
        Graph<T> sccReducedBa = SCCReduction.reduce(ba);
        Graph<T> simplifiedBa = Simplify.simplify(sccReducedBa);
        Graph<T> sfsReducedBa = SFSReduction.reduce(simplifiedBa);
        Formula.resetStatic();
        return sfsReducedBa;
    }

\end{lstlisting}
\end{minipage}

Drugim krokiem było stworzenie funkcji do budowania formuł, które wykorzystają potencjał Kotlina.
Każdy operator dwuargumentowy otrzymał wersję infiksową.
Kilka funkcji prezentuje listing \ref{lst:ltl_factory_extensions}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Przykładowe funkcje do budowania formuł w języku Kotlin.},captionpos=b,label={lst:ltl_factory_extensions}]

    infix fun <T> Formula<Matcher<T>>.and(right: Formula<Matcher<T>>)
            : Formula<Matcher<T>> = LtlFactory.And(this, right)

    infix fun <T> Formula<Matcher<T>>.implies(right: Formula<Matcher<T>>)
            : Formula<Matcher<T>> = LtlFactory.Implies(this, right)

    infix fun <T> Formula<Matcher<T>>.or(right: Formula<Matcher<T>>)
            : Formula<Matcher<T>> = LtlFactory.Or(this, right)

    fun <T> next(formula: Formula<Matcher<T>>): Formula<Matcher<T>>
            = LtlFactory.Next(formula)

    fun <T> globally(formula: Formula<Matcher<T>>): Formula<Matcher<T>>
            = LtlFactory.Globally(formula)

\end{lstlisting}
\end{minipage}

Najważniejsza część integracji to implementacja klasy automatu Büchiego, która umożliwi przechodzenie pomiędzy węzłami na podstawie kolejnego stanu systemu.
Stworzony został algorytm, który wybiera krawędź, którą należy podążyć.
Szukana jest taka, aby spełnić wszystkie stojące na jej straży wyrażenia.
W tym celu eksploruje się wewnętrzną strukturę grafu, sprawdza listę wyrażeń oraz ich ewentualną negację.
Następnie zwrócony zostaje nowy automat, którego aktualny węzeł, to ten znaleziony.

Klasa pozwala także na sprawdzenie, czy aktualnie znajduje się w stanie akceptującym.
Znajduje się tutaj również funkcja, która przyjmuje formułę, neguje ją oraz buduje automat Büchiego (zgodnie z listingiem \ref{lst:formula_to_graph}).
Kod prezentujący powyższą funkcjonalność znajduje się w listingu \ref{lst:ltl_automaton}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Implementacja automatu Büchiego.},captionpos=b,label={lst:ltl_automaton}]

public class LtlAutomaton<T> {
    private final Graph<Matcher<T>> buchiAutomaton;
    private final Node<Matcher<T>> currentNode;

    /* [...] */

    public LtlAutomaton<T> nextState(T targetSystemState) {
        val outgoingEdges = this.currentNode.getOutgoingEdges();
        if (outgoingEdges.isEmpty()) {
            throw new IllegalStateException("No more edges to follow");
        }

        Node<Matcher<T>> nextNode = outgoingEdges.stream()
                .sorted(noGuardEdgeToTheEndComparator)
                .filter(edge -> allGuardsMatch(targetSystemState, edge))
                .findFirst()
                .map(Edge::getNext)
                .orElse(this.currentNode);

        return new LtlAutomaton<>(this.buchiAutomaton, nextNode);
    }

    private boolean allGuardsMatch(Object system, Edge<Matcher<T>> edge) {
        return edge.getGuard().stream().allMatch(guard -> {
            val matches = guard.getAtom().matches(system);
            return guard.isNegated() != matches;
        });
    }

    public boolean isAccepting() {
        return this.currentNode.getAttributes().getString(ACCEPTING_KEY) != null;
    }

    public static <T> LtlAutomaton<T> prepareAutomaton(
            Formula<Matcher<T>> formulaToCheck) {
        val negatedFormula = formulaToCheck.negate();
        return newLtlAutomaton(negatedFormula);
    }
}

\end{lstlisting}
\end{minipage}

\newpage

\section{LTL Verifier}

Xxx
% szczegoly interfejsu restowego, poprawic pseudokod w rozdziale 3
% kod z formula 


\section{Baza danych}

% cassandra, jej wybor bo skalowana, ale tez wady (ACID), opis tabelek (z kolumnami)




% Osobny pseudokod dla GB, osobny dla LV
% info w jakim to jezyku, technologie wykorzystane
% po pseudokodzie opis bardziej techniczny, snippety kodu
% dokladny opis co apka robi
% opis całego API HTTP (pseudorestowego), opis verificationId
