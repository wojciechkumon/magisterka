\chapter{Rozproszona implementacja}

Opisany algorytm dostosowany został do środowiska rozproszonego.
Taka implementacja pozwala uzyskać wysoką wydajność całego systemu, który staje się skalowany.
Osiąga się to poprzez horyzontalne replikowanie aplikacji, która obsługuje weryfikację modelową.
Uruchomione zostaje wiele instancji tego samego serwisu.

Dzięki jego bezstanowości (żadnych danych sesyjnych, które przechowywane są w pamięci pomiędzy zapytaniami do serwera) nie ma znaczenia, która replika obsłuży żądanie.
Każda wykona je identycznie, a cały stan odczytywany i umieszczany jest z wykorzystaniem bazy danych.
W środowisku chmurowym cały system może być dynamicznie dostosowywane do aktualnych potrzeb, aby zapewnić szybkość, ale także nie marnować zasobów.

Poniżej przedstawiony zostanie opis zrealizowanego systemu.


\section{Graph Builder}

GB inicjuje cały algorytm oraz działa jako dostawca stanów dla weryfikatora (uzyskuje je od GP).
Najpierw wybierana jest formuła LTL, która zostanie sprawdzona (szczegóły jej specyfikacji w sekcji \ref{sec:LTL_formula_spec}).
Następnie zaczyna się już główna część algorytmu.
Pobierane są stany początkowe, po czym przekazywane są LV oraz heurystyce przeszukującej graf.

Każda weryfikacja posiada swój unikalny identyfikator, aby móc prowadzić wiele z nich równolegle na tym samym grafie stanów.
Nadawanie go następuje podczas wysyłania pierwszych stanów do LV.
Używa się go później w każdej komunikacji z weryfikatorem.

Wykorzystywane jest przeszukiwanie wszerz (BFS) zgodnie z fazą \textit{initialise} (algorytm \ref{alg:initialise}).
Kolejne stany uzyskiwane od GP zostają zapisywane w bazie danych, a także sprawdzane przez LV, który zwraca informacje o statusie weryfikacji.
Może ona zakończyć się szybciej (działanie w locie) w przypadku formuły, która nie jest spełniana przez graf.
W przeciwnym wypadku pobierane są kolejne stany aż do pełnej eksploracji.

Po odwiedzeniu wszystkich węzłów w grafie następuje wykonanie weryfikacji odpowiadającej liniom 4-8 w algorytmie \ref{alg:detectAcceptingCycle} przez LV.
Po tym etapie jednoznacznie wiadomo, czy formuła została spełniona.

Kod prezentujący funkcjonalność realizowaną przez GB znajduje się w listingu \ref{lst:GB_pseudocode}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Kod algorytmu realizowanego przez GB w języku Java.},captionpos=b,label={lst:GB_pseudocode}]
public VerificationState checkModel() {
  Collection<SystemState> states = initialStates.initialStates();
  List<StoredSystemState> saved = store.save(states).getNewlyStoredStates();
  heuristic.newStates(saved);
  VerificationId verificationId = verificationService.init(saved);
  while (heuristic.hasMoreToExplore()) {
    if (heuristic.shouldVisitState()) {
      StoredSystemState toVisit = heuristic.nextStateToVisit();
      Collection<Transition> transitions = description.allTransitionFromState(
          toVisit.getSystemState());
      heuristic.newTransitions(toVisit, transitions);
    }
    if (heuristic.shouldExploreTransition()) {
      Pair<StoredSystemState, Transition> toExplore = 
          heuristic.nextTransitionToExplore();
      Collection<SystemState> reachableStates = description.allReachableStates(
          toExplore.getFirst().getSystemState(), toExplore.getSecond());
      StoredStatesResult result = store.save(reachableStates);
      List<StoredSystemState> storedOnlyNewStates = result.getNewlyStoredStates();
      if (!storedOnlyNewStates.isEmpty()) {
        store.save(toExplore.getFirst(),
            storedOnlyNewStates, toExplore.getSecond());
        heuristic.newStates(storedOnlyNewStates);
      }
      List<StoredSystemState> storedOnlyOldStates = result.getAlreadyStoredStates();
      if (!storedOnlyOldStates.isEmpty()) {
        store.save(toExplore.getFirst(), storedOnlyOldStates,
            toExplore.getSecond());
      }
      List<StoredSystemState> allReachableStates =
          new ArrayList<>(storedOnlyNewStates);
      allReachableStates.addAll(storedOnlyOldStates);
      if (!allReachableStates.isEmpty()) {
        VerificationResult verificationResult = verifyNewStates(
            verificationId, toExplore, allReachableStates);
        if (verificationResult.getVerificationState() == FORMULA_UNSATISFIED) {
          return FORMULA_UNSATISFIED;
        }
      }
    }
  }
  VerificationResult finishResult = verificationService.finish(verificationId);
  return finishResult.getVerificationState();
}
\end{lstlisting}
\end{minipage}

% Osobny pseudokod dla GB, osobny dla LV
% info w jakim to jezyku, technologie wykorzystane
% po pseudokodzie opis bardziej techniczny, snippety kodu
% dokladny opis co apka robi
% opis całego API HTTP (pseudorestowego), opis verificationJobId


\section{Specyfikacja formuły LTL} \label{sec:LTL_formula_spec}

Obiektowa reprezentacja formuły LTL nie wystarcza, aby móc je tworzyć.
Potrzebny jest sposób umożliwiający zapis tekstem.
Dzięki temu można przygotowywać zestawy formuł, jakie powinien spełniać system, po czym wykorzystać je jako parametr dla weryfikatora.
Koniecznością więc było ich parsowanie.

Spełnić należało dwa wymagania.
Po pierwsze obsługiwać spójniki zdaniowe i operatory temporalne, jakie oferuje LTL.
Po drugie pozwolić elastyczność, co do samych warunków, tak aby móc je dowolnie komponować i łączyć.
Wspierać należało porównywanie dowolnych wartości modelu na różne sposoby, np. przez tę samą wartość, wyrażenia regularne, czy relację porządku.

Zamiast tworzenia własnego języka, wykorzystany został Kotlin poprzez jego silnik skryptowy.
Pozwala na nieograniczoną elastyczność w tworzeniu formuł.
Kod wykonywany jest locie i zamieniany na reprezentację obiektową.
Jego składnia pozwala na elegancką notację z wykorzystaniem operatorów infiksowych.

Obiekt formuły opisany został w sekcji \ref{sec:ltl2buchi}.
Do porównywania wartości wykorzystana została biblioteka \textit{Hamcrest} (\url{http://hamcrest.org}).
Oferuje ona bogaty zestaw komparatorów, możliwość ich łączenia i testowania na dowolnym obiekcie systemu.

Przykładowe formuły prezentuje listing \ref{lst:kotlin_formulas}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Przykładowe formuły LTL w języku Kotlin.},captionpos=b,label={lst:kotlin_formulas}]

val bfsPcEq1 = proposition(hasProperty<SystemState>("bfsHeuristicState", 
        hasProperty<Int>("pc", equalTo(1))))
val bfsPcGt1 = proposition(hasProperty<SystemState>("bfsHeuristicState",
        hasProperty<Int>("pc", greaterThan(1))))
val formula = globally(bfsPcEq1 implies finally(bfsPcGt1))


\end{lstlisting}
\end{minipage}

% TODO zapytać o sensowne formuły


\section{LTL to Büchi} \label{sec:ltl2buchi}

% TODO opis libki ltl2buchi https://github.com/fraimondi/ltl2buchi i jej integracji
% + opis calego obiektu formuly, parsowania, fabryka nad tym itp

\section{LTL Verifier}

% szczegoly interfejsu restowego, poprawic pseudokod w rozdziale 3

\section{Baza danych}

% cassandra, jej wybor bo skalowana, ale tez wady (ACID), opis tabelek (z kolumnami)
