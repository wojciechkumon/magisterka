\chapter{Weryfikacja modelowa}

Systemy tworzone przez ludzi są coraz bardziej złożone oraz zwiększa się ich rola w życiu każdego z nas.
Błędy w oprogramowaniu skutkują stratami finansowymi, wizerunkowymi, opóźnieniami, a także utratą zdrowia i życia ludzi. Dowodzą temu następujące przykłady: nieudany start Ariane-5 (04.06.1996), błąd w procesorach Pentium II Intela, czy źle działająca maszyna do radioterapii, która spowodowała śmierć sześciu pacjentów w latach 1985-1987.


\section{Weryfikacja systemu}

Weryfikacja systemu ma na celu ustalenie, czy projekt posiada oczekiwane właściwości. Mogą one być dość podstawowe (np. nigdy nie dojdzie do zakleszczenia) lub związane z domeną (np. nie można wypłacić więcej pieniędzy, niż jest na koncie). Specyfikacja dostarcza informacji, jak system może oraz jak nie może się zachowywać. Oprogramowanie uważa się za poprawne, jeśli spełnia wszystkie właściwości. Schemat weryfikacji został przedstawiony na rys. \ref{fig:system_verification_scheme}.

\begin{figure}[h]
    \centering
    \includegraphics[height=8cm,keepaspectratio]{img/system_verification_schematic_view.png}
    \caption{Schemat tworzenia systemu wraz z jego weryfikacją (źródło~\cite{Bai08}).}
    \label{fig:system_verification_scheme}
\end{figure}

Podstawową formą radzenia sobie z tym problemem jest testowanie oprogramowania (testy jednostkowe, integracyjne, systemowe itp.). Polega ono na uruchamianiu kodu dla różnych ścieżek wykonania, po czym porównuje się ich wyjścia z oczekiwanymi. Niestety, przetestowanie wszystkiego okazuje się praktycznie niemożliwe, zwykle sprawdzane są jedynie warunki brzegowe (stanowi to mały podzbiór wszystkich kombinacji). 


\section{Weryfikacja modelowa}

Podczas tworzenia skomplikowanych systemów, kładzie się coraz większy nacisk na testowanie poprawności oprogramowania. Metody formalne mają duży potencjał na tym polu. Ich wczesna integracja (podczas procesu projektowania) dostarcza efektywnych technik weryfikacji.
Intuicyjnie, metody formalne można rozważać jako matematykę stosowaną dla modelowania i analizy systemów informatycznych. Zapewniają one poprawność z matematyczną dokładnością.

Techniki weryfikacji bazujące na modelu opisują zachowanie systemu deterministycznie i kompletnie. Samo tworzenie pełnego modelu może wykryć luki lub niespójności.
Po jego stworzeniu, wraz z otaczającymi algorytmami, następuje eksploracja stanów systemu.
Dzieje się to w podejściu ``brute-force`` - przejrzane zostają wszystkie możliwe scenariusze.
W ten sposób udowadnia się spełnialność właściwości. Weryfikacji dotyczy również kolejność zdarzeń w czasie, np. czy system zawsze odpowie na żądania klienta w tym samym porządku, w jakim je otrzymał.

\vspace{0.5cm}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth,keepaspectratio]{img/model_checking_approach_schematic_view.png}
    \caption{Schemat podejścia weryfikacji modelowej (źródło~\cite{Bai08}).}
    \label{fig:model_checking_scheme}
\end{figure}

Podejście to świetnie sprawdza się w wykrywaniu (częstych) błędów związanych z wielowątkowością. Typowe oczekiwane właściwości:
\begin{itemize}
\item osiągalność (niemożliwe jest zakleszczenie)
\item bezpieczeństwo (coś niepożądanego nigdy nie wystąpi \cite{Alp87})
\item żywotność (coś "dobrego" w końcu nastąpi \cite{Alp85})
\item uczciwość (czy przy odpowiednich warunkach zdarzenie występuje powtarzalnie)
\item właściwości czasu rzeczywistego
\end{itemize}

\vspace{0.5cm}
Model systemu zazwyczaj generuje się automatycznie z opisu w odpowiednim języku lub dialekcie wspieranym przez narzędzie. 
Weryfikator modelowy przeszukuje kolejne stany. Następnie sprawdzane są pod kątem właściwości. Po znalezieniu naruszenia, prezentowany zostaje kontrprzykład wraz z całą ścieżką wykonania, która do niego prowadzi. Pozwala to łatwo odtworzyć całą ścieżkę, a także znaleźć niespójność, która wymaga zmiany modelu (lub właściwości) - schemat na rys. \ref{fig:model_checking_scheme}.

\vspace{0.5cm}
\noindent
To nie jedyne zalety, kolejnymi mocnymi stronami weryfikacji modelowej są:
\begin{itemize}
\item To ogólna metoda weryfikacji, która sprawdza się zarówno przy tworzeniu oprogramowania, jak i projektowaniu sprzętu (np. procesorów).
\item Wspiera częściową weryfikację - możemy sprawdzać poszczególne właściwości niezależnie, nawet gdy pełna specyfikacja nie jest gotowa.
\item Wszystkie możliwości zostają sprawdzone.
\item Dostarcza informacji diagnostycznych po wykryciu niespełnionej właściwości.
\item Uruchomienie weryfikatora nie wymaga ekspertyzy na tym polu.
\item Łatwo zintegrować to rozwiązanie z cyklem wytwarzania oprogramowania.
\item Obecnie wzrasta zainteresowania tym podejściem.
\end{itemize}

\vspace{0.5cm}
\noindent
Oczywiście nie brak także wad:
\begin{itemize}
\item Weryfikowany jest model systemu, a nie sam system. Brak tu gwarancji, że implementacja poprawnie go odtwarza.
\item Sprawdzane są tylko wykorzystane wymagania. Nie można wnioskować o poprawności właściwości, które nie zostały sprawdzone (błąd niedokładnej specyfikacji \cite{Lam05}).
\item Aplikacje oparte na dużej ilości danych mogą posiadać zbyt wiele stanów, aby je wszystkie wygenerować, a nawet ich liczba może być nieskończona.
\item Podatność na problem eksplozji przestrzeni stanów \cite{Cla11}.
\end{itemize}


\section{Logika LTL}

Logika LTL to jednak z logik temporalnych. Opiera się na liniowej strukturze czasu.
Jej składnia i semantyka pozwala precyzyjnie opisywać bogate spektrum właściwości systemu, włączając w to m.in bezpieczeństwo czy żywotność \cite{Bel17}.
``Temporalna`` oznacza umiejscawianie zdarzeń relatywnie względem innych, to pewna abstrakcja ponad czasem.  Z tego powodu niewykonalne jest sprawdzenie, czy maksymalne opóźnienie między zdarzeniami wynosi $500ms$.

Formuły LTL ponad zbiorem $AP$ wyrażeń atomowych przedstawia poniższa gramatyka:
\begin{gather}
\varphi::= true \,\, | \,\, false \,\, | \,\, a \,\, | \,\, \neg\varphi \,\, | \,\, \varphi \land \psi \,\, | \,\, \varphi \lor \psi \,\, | \,\, \varphi \Rightarrow \psi \,\, | \,\, \varphi \Leftrightarrow \psi \,\, | \nonumber\\
\mathbf{X}\varphi \,\, | \,\, \mathbf{F}\varphi \,\, | \,\, \mathbf{G}\varphi \,\, | \,\, \varphi\mathbf{U}\psi \,\, | \,\, (\varphi)\nonumber
\end{gather}
gdzie $a \in AP$ \\
Wyjaśnienie symboli (intuicyjna semantyka przedstawiona jest na rys. \ref{fig:ltl_semantics}): \\
$\mathbf{X}$ - $ne\mathbf{X}t$ - w następnym stanie \\
$\mathbf{U}$ - $\mathbf{U}ntil$ - aż do pewnego momentu w przyszłości \\
$\mathbf{F}$ - $\mathbf{F}inally$ - teraz lub w przyszłości \\
$\mathbf{G}$ - $\mathbf{G}lobally$ - teraz i w każdym momencie w przyszłości
\vspace{0.5cm}

\begin{figure}[h]
    \centering
    \includegraphics[height=11cm,keepaspectratio]{img/ltl_intuitive_semantics.png}
    \caption{Intuicyjna semantyka temporalnych modalności (źródło~\cite{Bai08}).}
    \label{fig:ltl_semantics}
\end{figure}

Przykładowe formuły LTL:
\begin{itemize}
\item $\mathbf{G}\neg\varphi$ - niemożliwe jest osiągnięcie stanu posiadającego $\varphi$ (bezpieczeństwo)
\item $\mathbf{G}(\varphi\Rightarrow\mathbf{F}\psi)$ - dla dowolnego stanu, jeśli posiada on $\varphi$, w końcu znajdziemy stan posiadający $\psi$ (żywotność)
\item $\mathbf{FG}\varphi$ - w końcu znajdziemy taki stan, od które zawsze spełnione będzie $\varphi$ (stabilność)
\end{itemize}


\section{Automat Büchiego}

W poprzedniej sekcji przedstawiona została liniowa logika LTL.
Niestety w obecnej postaci nie można jej wykorzystać do weryfikacji modelowej.
Punktem startowym jest system tranzycyjny $TS$ oraz formuła LTL $\varphi$, która formalizuje wymaganie dla $TS$.
Zadanie polega na sprawdzeniu, czy $TS \models \varphi$.
Jeśli $\varphi$ jest naruszona, szczegóły błędy powinny zostać dostarczone w celu jego naprawienia.
Manualne dowodzenie $TS \models \varphi$ to zazwyczaj bardzo trudny proces (zwykle systemy tranzycyjne są ogromne).
Dodatkowo rzadkim przypadkiem jest jedna formuła do weryfikacji.
Wymagania składają się na ich zbiór, taki jak $\varphi_1,...,\varphi_k$.
Wynikają z tego dwie opcje - można połączyć je w jedną $\varphi_1 \land ... \land \varphi_k$, aby uzyskać specyfikację wszystkich wymagań naraz lub traktować każde wymaganie $\varphi_i$ niezależnie.
Drugie podejście często okazuje się wydajniejsze.
Ponadto znalezienie błędu podczas sprawdzania pełnej specyfikacji nie dostarcza tak precyzyjnych danych diagnostycznych.

Pomiędzy logiką temporalną a teorią $\omega$-regularnych języków zachodzi bliska relacja \cite{Sis83}\cite{Wol83}.
Języki $\omega$-regularne są analogiczne do regularnych, lecz są zdefiniowane na nieskończonych słowach (zamiast skończonych).
Rozpoznawane są one przez automat Büchiego \cite{Buch66}.
To skończony automat, który operuje na nieskończonych słowach.
Nieskończone słowo jest akceptowane przez automat Büchiego wtedy i tylko wtedy, gdy stan akceptujący wystąpi nieskończenie wiele razy \cite{Sis87}.
Formalnie, deterministyczny automat Büchiego to krotka $A = (Q,\Sigma,\delta,q_0,F)$ składająca się z następujących elementów:
\begin{itemize}
\item $Q$ - skończony zbiór. Elementy $Q$ nazywane są stanami $A$.
\item $\Sigma$ - skończony zbiór nazywany alfabetem.
\item $\delta: Q \times \Sigma \rightarrow Q$ - funkcja nazywana funkcją tranzycji $A$.
\item $q_0$ - element $Q$, nazywany stanem początkowym $A$
\item $F \subseteq Q$ - warunek akceptujący. $A$ akceptuje dokładnie takie przejścia, gdzie przynajmniej jeden z nieskończenie często występujących stanów jest w $F$.
\end{itemize}
W niedeterministycznym automacie Büchiego (NBA - ang. \textit{non-deterministic Büchi automaton}), funkcja tranzycji $\delta$ zastąpiona jest relacją tranzycji $\Delta$, która zwraca zbiór stanów, a w miejscu stanu początkowego $q_0$ znajduje się zbiór stanów początkowych.

Uogólniony automat Büchiego (GBA - ang. \textit{generalized Büchi automaton}), to krotka $A = (Q,\Sigma,L,\Delta,Q_0,F)$:
\begin{itemize}
\item $Q$ - skończony zbiór. Elementy $Q$ nazywane są stanami $A$.
\item $\Sigma$ - skończony zbiór nazywany alfabetem.
\item $\delta: Q \times \Sigma \rightarrow 2^Q$ - funkcja nazywana funkcją tranzycji $A$.
\item $Q_0$ - podzbiór $Q$, nazywany stanami początkowymi
\item $F$ - warunek akceptujący. Składa się z zera lub więcej akceptujących zbiorów. Każdy taki zbiór $F_i \in F$ jest podzbiorem $Q$.
\end{itemize}
Pomimo różnic, GBA to ekwiwalent NBA w kategorii siły ekspresji.
W związku z tym możliwa jest jego konwersja do NBA \cite{Mer14}\cite{Dol95}.

Na rys. \ref{fig:nba1} oraz \ref{fig:nba2} znajdują się przykładowe NBA, wraz z odpowiadającymi im formułami.

\begin{figure}[h]
    \centering
    \includegraphics[width=8cm,keepaspectratio]{img/nba1.png}
    \caption{NBA dla $\mathbf{FG}a$ (źródło~\cite{Bai08}).}
    \label{fig:nba1}
\end{figure}
\begin{figure}[h]
    \centering
    \includegraphics[width=8cm,keepaspectratio]{img/nba2.png}
    \caption{NBA dla $\mathbf{G}(a \Rightarrow \mathbf{F}b)$ (źródło~\cite{Bai08}).}
    \label{fig:nba2}
\end{figure}

\noindent
Algorytm weryfikacji formuły LTL $\varphi$ w systemie tranzycyjnym $TS$ wygląda następująco:
\begin{enumerate}
    \item Zaneguj formułę $\varphi$ otrzymując $\neg\varphi$.
    \item Skonstruuj niedeterministyczny automat Büchiego $A_{\neg\varphi}$ odpowiadający formule $\neg\varphi$.
    \item Skonstruuj wynikowy system tranzycyjny $TS \otimes A$.
    \item Jeśli istnieje ścieżka $\pi$ w $TS \otimes A$ spełniająca akceptujący warunek $A$, zwróć ``nie`` wraz z opisem ścieżki $\pi$, w przeciwnym razie zwróć ``tak``.
\end{enumerate}

Sam schemat przedstawiający jak działa weryfikacja modelowa, kiedy wykorzystujemy logikę LTL do opisu właściwości, znajduje się na rys. \ref{fig:ltl_model_checking}.

\begin{figure}[h]
    \centering
    \includegraphics[height=11cm,keepaspectratio]{img/ltl_model_checking_overview.png}
    \caption{Przegląd weryfikacji modelowej LTL (źródło~\cite{Bai08}).}
    \label{fig:ltl_model_checking}
\end{figure}


\section{Eksploracja stanów systemu}

Posiadanie modelu systemu nie oznacza dostępności pełnego grafu stanów.
Może to być niepraktyczne lub nawet niemożliwe ze względu na liczbę stanów.
Preferowanym podejście to generowanie kolejnych stanów i ich weryfikacja ich w locie.
Takie rozwiązanie pozwala na wykrycie niespójności we wczesnym etapie, unikając generacji całej przestrzeni stanów.

Kolejnym czynnikiem wpływającym na wydajność jest sam algorytm budujący graf stanów.
W przypadku skomplikowanych systemów spodziewać się można olbrzymiego grafu, więc również czas jego tworzenia będzie odzwierciedlał rozmiar.
Moc obliczeniowa jednego procesora może okazać się niewystarczająca.
Warto więc wykorzystać algorytmy równoległe.
Standardowym rozwiązanie to DFS (przeszukiwanie w głąb - ang. \textit{Depth-first search}) \cite{God94}\cite{Hol99}.
Występuje w wielu wersjach mających zwiększyć jego wydajność.
Z czasem powstała też nowa grupa algorytmów.
Opiera się na podziale grafu na silnie spójne składowe, wywodzi się ona z algorytmu Tarjana \cite{Jac05}.
Złożoność obliczeniowa tych algorytmów jest liniowa $O(m + n)$, gdzie $m$ to liczba krawędzi, a $n$ oznacza ilość stanów.
Wszystkie korzystają z tej samej zasady eksploracji - przeszukiwania wstecznego (ang. \textit{post-order}).
Faktem jest, że problem takiego przeszukiwania jest P-zupełny, więc skalowany, równoległy algorytm tego typu najprawdopodobniej nie istnieje \cite{Reif85}.

Algorytmem wartym uwagi jest \textit{on-the-fly OWCTY algorithm} \cite{Bar12}.
Opiera on się na algorytmie OWCTY (ang. \textit{One Way Catch Them Young}) \cite{Cer03} oraz MAP (ang. \textit{Maximal Accepting Predecessor}) \cite{Bri04}.
Co więcej, pozwala na zrównoleglenie obliczeń.
